---
author: Yossi Spektor
authorTwitter: SpektorYossi
category: software
title: "From Maven To Gradle"
date: "2024-08-12T20:19:03.284Z"
description: "Learn How To Transition From Maven To Gradle."
tags:
  - kotlin
  - java
  - maven
  - gradle

excerpt: Kotlin is a modern language which tries to simplify common actions which usually result in a lot of Java boilerplate. Its approach to concurrency is a breath of fresh air...
---

<div style="display:flex;justify-content:center;padding-right:10%;padding-bottom:50px;padding-top:30px;">
    <img src="/images/blog/kotlin_logo.svg"
    alt="Kotlin Logo"
    style="margin:0;"
    />
</div>

1. [What Is Gradle?](#what-is-gradle)

### <a name="what-is-gradle"></a>What Is Gradle?
TDB

[Maven vs Gradle feature comparison](https://gradle.org/maven-vs-gradle)

### Build Lifecycle
Maven builds are based around the concept of build lifecycles that consist of a set of fixed phases while Gradle uses its own [build model](https://docs.gradle.org/current/userguide/build_lifecycle.html#build_lifecycle). For Maven users transitioning to Gradle, it provides a helper feature that can mimic Maven’s phases: lifecycle tasks.
Here is a list of some of the main Maven phases and the Gradle tasks that they map to:

**clean** -> use the clean task provided by the Base Plugin.

**compile** -> use the classes task provided by the Java Plugin and other JVM language plugins. This compiles all classes for all source files of all languages and also performs resource filtering via the processResources task.

**test** -> use the test task provided by the Java Plugin. It runs the unit tests, and more specifically, the tests that make up the test source set.

**package** -> use the assemble task provided by the Base Plugin. This builds whatever is the appropriate package for the project; for example, a JAR for Java libraries or a WAR for traditional Java webapps.

**verify** -> use the check task provided by the Base Plugin. This runs all verification tasks that are attached to it, which typically includes the unit tests, any static analysis tasks — such as Checkstyle — and others. If you want to include integration tests, you will have to configure these **manually**.

**install** -> use the `publishToMavenLocal` task provided by the Maven Publish Plugin. Note that Gradle builds don’t require you to "install" artifacts as you have access to more appropriate features like inter-project dependencies and composite builds. **You should only use publishToMavenLocal for interoperating with Maven builds**.

### Declaring Dependencies
The Maven dependency below
```xml
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.12</version>
    </dependency>
</dependencies>
```
can be converted to the following Gradle dependency:
```kotlin
dependencies {
    implementation("log4j:log4j:1.2.12")  
}
```
The above string identifier takes the Maven values of groupId, artifactId and version, although Gradle refers to them as group, module and version.

### Differences
- One notable difference between the two tools is in how they manage version conflicts. Maven uses a "closest" match algorithm, whereas Gradle picks the newest. Don’t worry though, you have a lot of control over which versions are selected, as documented in Managing Transitive Dependencies.
