---
author: Yossi Spektor
authorTwitter: SpektorYossi
category: software
title: "From Maven To Gradle"
date: "2024-08-12T20:19:03.284Z"
description: "Learn How To Transition From Maven To Gradle."
tags:
  - kotlin
  - java
  - maven
  - gradle

excerpt: Kotlin is a modern language which tries to simplify common actions which usually result in a lot of Java boilerplate. Its approach to concurrency is a breath of fresh air...
---

<div style="display:flex;justify-content:center;padding-right:10%;padding-bottom:50px;padding-top:30px;">
    <img src="/images/blog/kotlin_logo.svg"
    alt="Kotlin Logo"
    style="margin:0;"
    />
</div>

1. [What Is Gradle?](#what-is-gradle)

### <a name="what-is-gradle"></a>What Is Gradle?
TDB

[Maven vs Gradle feature comparison](https://gradle.org/maven-vs-gradle)

### Build Lifecycle
Maven builds are based around the concept of build lifecycles that consist of a set of fixed phases while Gradle uses its own [build model](https://docs.gradle.org/current/userguide/build_lifecycle.html#build_lifecycle). For Maven users transitioning to Gradle, it provides a helper feature that can mimic Maven’s phases: lifecycle tasks.
Here is a list of some of the main Maven phases and the Gradle tasks that they map to:

**clean** -> use the clean task provided by the Base Plugin.

**compile** -> use the classes task provided by the Java Plugin and other JVM language plugins. This compiles all classes for all source files of all languages and also performs resource filtering via the processResources task.

**test** -> use the test task provided by the Java Plugin. It runs the unit tests, and more specifically, the tests that make up the test source set.

**package** -> use the assemble task provided by the Base Plugin. This builds whatever is the appropriate package for the project; for example, a JAR for Java libraries or a WAR for traditional Java webapps.

**verify** -> use the check task provided by the Base Plugin. This runs all verification tasks that are attached to it, which typically includes the unit tests, any static analysis tasks — such as Checkstyle — and others. If you want to include integration tests, you will have to configure these **manually**.

**install** -> use the `publishToMavenLocal` task provided by the Maven Publish Plugin. Note that Gradle builds don’t require you to "install" artifacts as you have access to more appropriate features like inter-project dependencies and composite builds. **You should only use publishToMavenLocal for interoperating with Maven builds**.

### Declaring Dependencies
The Maven dependency below
```xml
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.12</version>
    </dependency>
</dependencies>
```
can be converted to the following Gradle dependency:
```kotlin
dependencies {
    implementation("log4j:log4j:1.2.12")  
}
```
The above string identifier takes the Maven values of groupId, artifactId and version, although Gradle refers to them as group, module and version.

Below is the mapping between Maven and Gradle dependencies scopes:
**compile** -> in most cases you should simply use the `implementation` configuration, particularly if you’re building an application or webapp. But if you’re building a library, you can learn about which dependencies should be declared using `api` configuration [here](https://docs.gradle.org/current/userguide/building_java_projects.html#sec:building_java_libraries).

**runtime** -> use the `runtimeOnly` configuration.

**test** -> Gradle distinguishes between those dependencies that are required to compile a project’s tests and those that are only needed to run them. Dependencies required for test compilation should be declared against the `testImplementation` configuration. Those that are only required for running the tests should use `testRuntimeOnly`.

You can read more about `provided` and `import` scopes [here](https://docs.gradle.org/current/userguide/migrating_from_maven.html)

### Repositories
Unlike Maven, it has no default repository and so you have to declare at least one. In order to have the same behavior as your Maven build, just configure Maven Central in your Gradle build, like this:
```kotlin
repositories {
    mavenCentral()
}
```

### Controlling dependency versions
The existence of transitive dependencies means that you can very easily end up with multiple versions of the same dependency in your dependency graph. By default, Gradle will pick the newest version of a dependency in the graph, but that’s not always the right solution. That’s why it provides several mechanisms for controlling which version of a given dependency is resolved.

#### Dependency Constraints
Provides a way to enforce specific transitive dependency version across all the dependencies of a project:
```kotlin
dependencies {
    implementation("org.apache.httpcomponents:httpclient") // note that version is not specified here
    constraints {
        implementation("org.apache.httpcomponents:httpclient:4.5.3") {
            because("previous versions have a bug impacting this application")
        }
        implementation("commons-codec:commons-codec:1.11") {
            because("version 1.9 pulled from httpclient has bugs affecting this application")
        }
    }
}
```
In the example, all versions are omitted from the dependency declaration. Instead, the versions are defined in the constraints block. The version definition for `commons-codec:1.11` is only taken into account if `commons-codec` is brought in as transitive dependency, since `commons-codec` is not defined as dependency in the project. Otherwise, the constraint has no effect.

#### Bills of Materials (Maven BOMs)
Maven allows you to share dependency constraints by defining dependencies inside a <dependencyManagement> section of a POM file that has a packaging type of pom. This special type of POM (a BOM) can then be imported into other POMs so that you have consistent library versions across your projects.
Gradle can use such BOMs for the same purpose, using a special dependency syntax based on platform() and enforcedPlatform() methods. You simply declare the dependency in the normal way, but wrap the dependency identifier in the appropriate method, as shown in this example that "imports" the Spring Boot Dependencies BOM:
```kotlin
dependencies {
    implementation(platform("org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE"))  
    implementation("com.google.code.gson:gson")  
    implementation("dom4j:dom4j")
}
```

#### Overriding Transitive Versions
Gradle also allows to force dependency version on dependency level:
```kotlin
dependencies {
    implementation("org.apache.httpcomponents:httpclient:4.5.4")
    implementation("commons-codec:commons-codec") {
        version {
            strictly("1.9")
        }
    }
}
```
Using the above method may cause [issues](https://docs.gradle.org/current/userguide/dependency_downgrade_and_exclude.html#sec:strict-version-consequences) to consumers of the a module.

#### Exclude Dependencies
Gradle's exclude handling is, in contrast to Maven, taking the whole dependency graph into account. So if there are multiple dependencies on a library, excludes are only exercised if all dependencies agree on them. For example:
```kotlin
dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
    implementation("com.opencsv:opencsv:4.6") // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
}
```
If we add `opencsv` as another dependency to our project above, which also depends on `commons-beanutils`, `commons-collection` is no longer excluded as `opencsv` itself does not exclude it.
If we still want to have `commons-collections` excluded, because our combined usage of `commons-beanutils` and `opencsv` does not need it, we need to exclude it from the transitive dependencies of `opencsv` as well.
```kotlin
dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
    implementation("com.opencsv:opencsv:4.6") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
}
```
Lastly, if you want to share constraints between modules in a multi-module project you can use [Java Platform Plugin](https://docs.gradle.org/current/userguide/java_platform_plugin.html#java_platform_plugin).

### Differences
- One notable difference between the two tools is in how they manage version conflicts. Maven uses a "closest" match algorithm, whereas Gradle picks the newest. Don’t worry though, you have a lot of control over which versions are selected, as documented in Managing Transitive Dependencies.
